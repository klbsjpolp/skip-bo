<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skip-Bo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script>
        // Apply theme on initial load to prevent FOUC
        (function() {
            const theme = localStorage.getItem('skipbo_theme') || 'light';
            document.documentElement.classList.add(`theme-${theme}`);
        })();
    </script>
</head>
<body class="p-4 md:p-10">
<div class="theme-switcher flex justify-center gap-4 mb-6">
    <button data-theme="light">Clair</button>
    <button data-theme="dark">Sombre</button>
    <button data-theme="metro">Metro</button>
    <button data-theme="neon">Néon</button>
    <button data-theme="retro">Rétro</button>
</div>

<div id="game-container" class="max-w-7xl mx-auto">
    <div id="ai-area" class="player-area">
        <h2>Joueur IA</h2>
        <div class="flex justify-between items-start">
            <div class="text-center w-32">
                <h3>Talon (<span id="ai-stock-count"></span>)</h3>
                <div id="ai-stock" class="card mx-auto">?</div>
            </div>
            <div class="text-center">
                <h3>Sa main</h3>
                <div id="ai-hand" class="hand-area"></div>
            </div>
            <div class="text-center">
                <h3>Piles de défausse</h3>
                <div id="ai-discard-piles" class="discard-piles"></div>
            </div>
        </div>
    </div>

    <div id="center-area" class="center-area">
        <div class="flex items-start">
            <div class="text-center w-32">
                <h2>Pioche (<span id="deck-count"></span>)</h2>
                <div id="deck" class="card back shadow-lg mx-auto"></div>
            </div>
            <div class="text-center">
                <h2>Piles de construction</h2>
                <div id="build-piles" class="discard-piles"></div>
            </div>
        </div>
    </div>

    <div id="message-box" class="text-center font-bold text-xl my-4 h-8"></div>

    <div id="player-area" class="player-area">
        <h2>Votre tour</h2>
        <div class="flex justify-between items-start">
            <div class="text-center w-32">
                <h3>Talon (<span id="player-stock-count"></span>)</h3>
                <div id="player-stock" class="card mx-auto"></div>
            </div>
            <div class="text-center">
                <h3>Votre main</h3>
                <div id="player-hand" class="hand-area"></div>
            </div>
            <div class="text-center">
                <h3>Piles de défausse</h3>
                <div id="player-discard-piles" class="discard-piles"></div>
            </div>
        </div>
    </div>

    <div class="text-center mt-5">
        <button id="restart-button" class="hidden bg-indigo-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">Rejouer</button>
    </div>
</div>

<script type="module">
    import CONFIG from './config.js';
    import SkipBoGame from './game.js';
    import SkipBoUI from './ui.js';

    // --- Theme Management ---
    class ThemeManager {
        constructor() {
            this.themeSwitcher = document.querySelector('.theme-switcher');
            this.bodyElement = document.body;
            this.init();
        }

        init() {
            this.loadTheme();
            this.themeSwitcher.addEventListener('click', (e) => {
                const theme = e.target.dataset.theme;
                if (theme) {
                    this.applyTheme(theme);
                    this.saveTheme(theme);
                }
            });
        }

        applyTheme(themeName) {
            this.bodyElement.className = this.bodyElement.className.replace(/theme-\w+/g, '');
            this.bodyElement.classList.add(`theme-${themeName}`);

            this.themeSwitcher.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.theme === themeName);
            });
        }

        saveTheme(themeName) {
            localStorage.setItem(CONFIG.THEMES.STORAGE_KEY, themeName);
        }

        loadTheme() {
            const savedTheme = localStorage.getItem(CONFIG.THEMES.STORAGE_KEY) || CONFIG.THEMES.DEFAULT;
            document.body.className = '';
            this.applyTheme(savedTheme);
        }
    }

    // --- AI Logic ---
    class AIPlayer {
        constructor(game, ui) {
            this.game = game;
            this.ui = ui;
        }

        async playTurn() {
            if (this.game.gameIsOver) return;

            const ai = this.game.players[1];

            // Try to play from stock
            if (ai.stock.length > 0) {
                const stockCard = ai.stock[ai.stock.length - 1];
                if (this.game.playCard(1, stockCard, 'stock')) {
                    await this.delay(CONFIG.UI.AI_PLAY_DELAY);
                    this.checkAndContinue();
                    return;
                }
            }

            // Try to play from hand
            for (let i = 0; i < ai.hand.length; i++) {
                if (this.game.playCard(1, ai.hand[i], 'hand', i)) {
                    await this.delay(CONFIG.UI.AI_PLAY_DELAY);
                    this.checkAndContinue();
                    return;
                }
            }

            // Try to play from discard piles
            for (let i = 0; i < ai.discard.length; i++) {
                if (ai.discard[i].length > 0) {
                    const discardCard = ai.discard[i][ai.discard[i].length - 1];
                    if (this.game.playCard(1, discardCard, 'discard', i)) {
                        await this.delay(CONFIG.UI.AI_PLAY_DELAY);
                        this.checkAndContinue();
                        return;
                    }
                }
            }

            // Discard if no plays available
            if (ai.hand.length > 0) {
                const emptyDiscardIndex = ai.discard.findIndex(pile => pile.length === 0);
                const discardIndex = emptyDiscardIndex !== -1 ? emptyDiscardIndex : 0;
                this.game.discardCard(1, ai.hand.length - 1, discardIndex);
            }

            gameController.endTurn();
        }

        checkAndContinue() {
            const winResult = this.game.checkForWinner();
            if (winResult.hasWinner) {
                gameController.handleGameEnd(winResult);
                return;
            }

            this.ui.updateUI();
            setTimeout(() => this.playTurn(), CONFIG.UI.AI_PLAY_DELAY);
        }

        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    }

    // --- Game Controller ---
    class GameController {
        constructor() {
            this.game = new SkipBoGame();
            this.ui = new SkipBoUI(this.game);
            this.ai = new AIPlayer(this.game, this.ui);
            this.themeManager = new ThemeManager();
            this.initEventListeners();
            this.initGame();
        }

        initEventListeners() {
            // Player area click handler
            document.getElementById('player-area').addEventListener('click', (e) => {
                this.handlePlayerAreaClick(e);
            });

            // Build pile click handler
            document.getElementById('build-piles').addEventListener('click', (e) => {
                this.handleBuildPileClick(e);
            });

            // Restart button
            document.getElementById('restart-button').addEventListener('click', () => {
                this.initGame();
            });
        }

        handlePlayerAreaClick(e) {
            if (this.game.currentPlayerIndex !== 0 || this.game.gameIsOver) return;

            const target = e.target;
            const discardPileStack = target.closest('.discard-pile-stack');

            // Handle discarding
            if (this.game.selectedCard && this.game.selectedCard.source === 'hand' && discardPileStack) {
                const discardPileIndex = parseInt(discardPileStack.dataset.index);
                this.game.discardCard(0, this.game.selectedCard.index, discardPileIndex);
                this.endTurn();
                return;
            }

            // Handle card selection
            const cardElement = target.closest('[data-source]');
            if (!cardElement) return;

            const source = cardElement.dataset.source;
            let index = source === 'discard' ?
                parseInt(target.closest('.discard-pile-stack').dataset.index) :
                parseInt(cardElement.dataset.index);

            this.selectCard(cardElement, source, index);
        }

        selectCard(cardElement, source, index) {
            const player = this.game.players[0];

            if (source === 'stock' && player.stock.length === 0) return;

            let cardValue;
            if (source === 'stock') {
                cardValue = player.stock[player.stock.length - 1];
            } else {
                const cardStr = cardElement.dataset.card;
                cardValue = cardStr === 'SB' ? 'SB' : parseInt(cardStr);
            }

            if (this.game.selectedCard && this.game.selectedCard.element === cardElement) {
                this.ui.clearSelection();
            } else {
                this.ui.setSelection({
                    value: cardValue,
                    source: source,
                    index: index,
                    element: cardElement
                });
            }
        }

        handleBuildPileClick(e) {
            if (this.game.currentPlayerIndex !== 0 || this.game.gameIsOver || !this.game.selectedCard) return;

            const target = e.target.closest('[data-pile-index]');
            if (!target) return;

            const pileIndex = parseInt(target.dataset.pileIndex);
            const played = this.game.playCard(
                0,
                this.game.selectedCard.value,
                this.game.selectedCard.source,
                this.game.selectedCard.index,
                pileIndex
            );

            if (played) {
                const winResult = this.game.checkForWinner();
                if (winResult.hasWinner) {
                    this.handleGameEnd(winResult);
                    return;
                }

                // Store the source before clearing selection
                const wasFromHand = this.game.selectedCard?.source === 'hand';

                this.ui.clearSelection();
                this.ui.updateUI();

                // Check if hand is empty and refill
                if (wasFromHand && this.game.players[0].hand.length === 0) {
                    this.ui.showMessage(CONFIG.MESSAGES.HAND_EMPTY_REFILL, CONFIG.UI.HAND_REFILL_DELAY);
                    setTimeout(() => {
                        this.game.drawHand(0);
                        this.ui.showMessage(CONFIG.MESSAGES.PLAYER_TURN, 0);
                        this.ui.updateUI();
                    }, CONFIG.UI.HAND_REFILL_DELAY);
                }
            }
        }

        initGame() {
            this.game.initGame();
            this.ui.hideRestartButton();
            this.game.drawHand(this.game.currentPlayerIndex+1 % 2);
            this.startTurn();
        }

        startTurn() {
            const winResult = this.game.checkForWinner();
            if (winResult.hasWinner) {
                this.handleGameEnd(winResult);
                return;
            }

            const drawResult = this.game.drawHand(this.game.currentPlayerIndex);
            if (!drawResult.success) {
                this.ui.showMessage(drawResult.message, 0);
                return;
            }

            this.ui.updateUI();

            const currentPlayer = this.game.getCurrentPlayer();
            if (currentPlayer.isAI) {
                this.ui.showMessage(CONFIG.MESSAGES.AI_TURN, 0);
                setTimeout(() => this.ai.playTurn(), CONFIG.UI.AI_TURN_DELAY);
            } else {
                this.ui.showMessage(CONFIG.MESSAGES.PLAYER_TURN, 0);
            }
        }

        endTurn() {
            if (this.game.gameIsOver) return;
            this.ui.clearSelection();
            this.game.switchTurn();
            this.startTurn();
        }

        handleGameEnd(winResult) {
            this.game.gameIsOver = true;
            this.ui.showGameEnd(winResult.isAI);
            this.ui.updateCursors();
        }
    }

    // Initialize the game
    const gameController = new GameController();

    // Make gameController available globally for AI callbacks
    window.gameController = gameController;
</script>
</body>
</html>
